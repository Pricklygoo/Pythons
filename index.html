<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PYTHONS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #121212;
            color: #E0E0E0;
            overflow: hidden;
            touch-action: none;
        }
        .pixelated {
            image-rendering: pixelated;
        }
        .neon-text {
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #0fa,
                0 0 30px #0fa,
                0 0 40px #0fa,
                0 0 55px #0fa,
                0 0 75px #0fa;
        }
        .control-card {
            background-color: rgba(30, 30, 30, 0.8);
            border: 2px solid #0fa;
            box-shadow: 0 0 15px #0fa;
        }
        canvas {
            background-color: #000;
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .btn-primary {
            background-color: #0fa;
            color: #121212;
            border: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px #0fa;
        }
        .btn-primary:hover {
            background-color: #fff;
            color: #0fa;
            transform: scale(1.05);
            box-shadow: 0 0 20px #0fa;
        }
        .player-score {
            transition: all 0.3s ease;
            text-shadow: 0 0 5px currentColor;
        }
        .player-score.highlight {
            transform: scale(1.2);
            filter: brightness(1.5);
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="container" class="w-full h-screen flex flex-col items-center justify-center p-4">

        <!-- Menu Screen -->
        <div id="menu-screen" class="hidden text-center">
            <h1 class="text-6xl md:text-8xl font-bold mb-8 neon-text">PYTHONS</h1>
            <h2 class="text-2xl md:text-3xl mb-12">MULTIPLAYER</h2>

            <div class="mb-8">
                <h3 class="text-xl mb-4">Select Number of Players</h3>
                <div id="player-count-selector" class="flex justify-center gap-4">
                    <button data-players="2" class="player-option text-2xl py-3 px-6 rounded-lg border-2 border-gray-600 focus:border-green-400 focus:bg-green-900 focus:outline-none transition">2</button>
                    <button data-players="3" class="player-option text-2xl py-3 px-6 rounded-lg border-2 border-gray-600 focus:border-green-400 focus:bg-green-900 focus:outline-none transition">3</button>
                    <button data-players="4" class="player-option text-2xl py-3 px-6 rounded-lg border-2 border-gray-600 focus:border-green-400 focus:bg-green-900 focus:outline-none transition">4</button>
                </div>
            </div>

            <div class="mb-8 max-w-md mx-auto">
                <h3 class="text-xl mb-4">Score to Win: <span id="score-display">30</span></h3>
                <input id="score-slider" type="range" min="10" max="80" value="30" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>

            <button id="start-game-btn" class="btn-primary text-3xl font-bold py-4 px-10 rounded-xl disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Start Game
            </button>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-12 max-w-6xl mx-auto">
                <!-- Player 1 Controls -->
                <div class="control-card p-4 rounded-lg">
                    <h4 class="text-lg mb-2" style="color: #34D399;">Player 1</h4>
                    <p>WASD Keys</p>
                </div>
                <!-- Player 2 Controls -->
                <div class="control-card p-4 rounded-lg">
                    <h4 class="text-lg mb-2" style="color: #F87171;">Player 2</h4>
                    <p>IJKL Keys</p>
                </div>
                <!-- Player 3 Controls -->
                <div class="control-card p-4 rounded-lg">
                    <h4 class="text-lg mb-2" style="color: #60A5FA;">Player 3</h4>
                    <p>Arrow Keys</p>
                </div>
                <!-- Player 4 Controls -->
                <div class="control-card p-4 rounded-lg">
                    <h4 class="text-lg mb-2" style="color: #FBBF24;">Player 4</h4>
                    <p>Numpad 8456</p>
                </div>
            </div>
             <p class="mt-8 text-sm text-gray-400">First to the selected score wins! Wall hits reset score. Player hits lose 5 points.</p>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden w-full h-full flex-col items-center">
            <div id="scoreboard" class="flex justify-around mb-2 text-2xl font-bold w-full max-w-6xl"></div>
            <canvas id="game-canvas"></canvas>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden text-center">
            <h1 id="winner-text" class="text-3xl md:text-5xl font-bold mb-4 neon-text"></h1>
            <p id="insult-text" class="text-xl text-gray-300 mb-8 max-w-2xl mx-auto"></p>
            <div class="flex justify-center gap-6">
                <button id="play-again-btn-win" class="btn-primary text-2xl font-bold py-4 px-8 rounded-xl">Play Again</button>
                <button id="exit-btn-win" class="btn-primary text-2xl font-bold py-4 px-8 rounded-xl">Exit</button>
            </div>
        </div>
        
        <!-- Pause Menu Screen -->
        <div id="pause-screen" class="hidden overlay">
            <div class="text-center bg-gray-800 p-10 rounded-lg shadow-lg border-2 border-gray-600">
                <h1 class="text-5xl mb-8 neon-text">Paused</h1>
                <div class="flex flex-col gap-4">
                     <button id="restart-btn" class="btn-primary text-2xl font-bold py-3 px-8 rounded-xl">Restart</button>
                     <button id="exit-btn" class="btn-primary text-2xl font-bold py-3 px-8 rounded-xl">Exit to Menu</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        const menuScreen = document.getElementById('menu-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const playerCountSelector = document.getElementById('player-count-selector');
        const startGameBtn = document.getElementById('start-game-btn');
        const restartBtn = document.getElementById('restart-btn');
        const exitBtn = document.getElementById('exit-btn');
        const scoreSlider = document.getElementById('score-slider');
        const scoreDisplay = document.getElementById('score-display');
        const scoreboard = document.getElementById('scoreboard');
        const winnerText = document.getElementById('winner-text');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const insultText = document.getElementById('insult-text');
        const playAgainBtnWin = document.getElementById('play-again-btn-win');
        const exitBtnWin = document.getElementById('exit-btn-win');


        // --- Game Configuration ---
        const TILE_SIZE = 20;
        let winningScore = 30;
        const GAME_SPEED = 120; // in milliseconds
        const RENDER_INTERVAL = 16; // for smoother animations
        const POWERUP_DURATION = 10000; // 10 seconds
        const POWERUP_LIFESPAN = 8000; // 8 seconds
        const POWERUP_SPAWN_CHANCE = 0.002;

        let tileCountX, tileCountY;
        let players = [];
        let food = {};
        let powerup = { active: false, x: -1, y: -1, lifespan: 0, pulseState: 0 };
        let playerCount = 0;
        let gameLoopInterval;
        let isPaused = false;
        let lastFrameTime = 0;
        
        // --- Audio ---
        let uiSynth, foodSynth, errorSynth, winSynth, powerupSynth;
        let audioInitialized = false;

        function initializeAudio() {
            if (audioInitialized) return;
            Tone.start();
            uiSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).toDestination();
            foodSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
            errorSynth = new Tone.MembraneSynth().toDestination();
            winSynth = new Tone.PolySynth(Tone.Synth).toDestination();
            powerupSynth = new Tone.FMSynth({
                harmonicity: 3,
                modulationIndex: 10,
                envelope: { attack: 0.01, decay: 0.2 },
                modulationEnvelope: { attack: 0.05, decay: 0.1 }
            }).toDestination();
            audioInitialized = true;
        }

        function playClickSound() { if (uiSynth) uiSynth.triggerAttackRelease("C4", "8n"); }
        function playFoodSound() { if (foodSynth) foodSynth.triggerAttackRelease("G5", "16n"); }
        function playErrorSound() { if (errorSynth) errorSynth.triggerAttackRelease("C2", "8n"); }
        function playWinSound() { if (winSynth) { const now = Tone.now(); winSynth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now); } }
        function playPowerupSound() { if (powerupSynth) powerupSynth.triggerAttackRelease("A4", "4n"); }


        const insults = [
            "Guess you couldn't handle the python's charm! Too slow!",
            "Looks like you got constricted by the competition.",
            "Were you shedding your skin? You were moving so slowly!",
            "You've been out-hissed! Better luck next time.",
            "A python's pace is too much for you, I see.",
            "You really bit off more than you could chew.",
            "That was a crushing defeat. Literally.",
            "You need to shed that slow-moving strategy.",
            "Someone's been charmed, and it wasn't the snake.",
            "Did you get lost in the undergrowth?",
            "You're not cold-blooded, just slow-blooded.",
            "Your chances of winning are boa-constrictedly small.",
            "Don't be rattled, try again!",
            "Looks like you got coiled up in your own plans.",
            "You moved with the speed of a digesting python.",
            "Maybe try being less slithery and more speedy.",
            "Fang-tastic effort, but not fast enough.",
            "You've been scaled down to size.",
            "That performance was a bit of a drag-on.",
            "You met your anacon-demise!"
        ];

        const PLAYER_CONFIG = [
            { color: '#34D399', controls: { 'KeyW': 'up', 'KeyS': 'down', 'KeyA': 'left', 'KeyD': 'right' } },
            { color: '#F87171', controls: { 'KeyI': 'up', 'KeyK': 'down', 'KeyJ': 'left', 'KeyL': 'right' } },
            { color: '#60A5FA', controls: { 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right' } },
            { color: '#FBBF24', controls: { 'Numpad8': 'up', 'Numpad5': 'down', 'Numpad4': 'left', 'Numpad6': 'right' } },
        ];
        
        window.onload = () => { menuScreen.classList.remove('hidden'); };


        // --- Event Listeners ---
        window.addEventListener('resize', setupCanvas);
        document.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                initializeAudio();
                playClickSound();
            });
        });

        playerCountSelector.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                document.querySelectorAll('.player-option').forEach(btn => btn.classList.remove('bg-green-700'));
                e.target.classList.add('bg-green-700');
                playerCount = parseInt(e.target.dataset.players);
                startGameBtn.disabled = false;
            }
        });
        scoreSlider.addEventListener('input', (e) => {
            winningScore = parseInt(e.target.value);
            scoreDisplay.textContent = winningScore;
        });
        startGameBtn.addEventListener('click', startGame);
        playAgainBtnWin.addEventListener('click', () => { gameOverScreen.classList.add('hidden'); startGame(); });
        exitBtnWin.addEventListener('click', () => { gameOverScreen.classList.add('hidden'); menuScreen.classList.remove('hidden'); });
        restartBtn.addEventListener('click', () => { pauseScreen.classList.add('hidden'); isPaused = false; startGame(); });
        exitBtn.addEventListener('click', () => { pauseScreen.classList.add('hidden'); isPaused = false; if (gameLoopInterval) clearInterval(gameLoopInterval); gameLoopInterval = null; gameScreen.classList.add('hidden'); menuScreen.classList.remove('hidden'); });
        document.addEventListener('keydown', handleKeyPress);
        
        // --- Game Setup ---
        function setupCanvas() {
            const scoreboardHeight = scoreboard.offsetHeight;
            const container = document.getElementById('container');
            const availableWidth = container.clientWidth * 0.9;
            const availableHeight = (window.innerHeight - scoreboardHeight) * 0.9;
            tileCountX = Math.floor(availableWidth / TILE_SIZE);
            tileCountY = Math.floor(availableHeight / TILE_SIZE);
            canvas.width = tileCountX * TILE_SIZE;
            canvas.height = tileCountY * TILE_SIZE;
            if (gameLoopInterval) { drawGame(); }
        }

        function createPlayer(id) {
            const config = PLAYER_CONFIG[id-1];
            let startPos;
            switch(id) {
                case 1: startPos = { x: 3, y: 3 }; break;
                case 2: startPos = { x: tileCountX - 4, y: 3 }; break;
                case 3: startPos = { x: 3, y: tileCountY - 4 }; break;
                case 4: startPos = { x: tileCountX - 4, y: tileCountY - 4 }; break;
            }
            return {
                id: id, snake: [startPos], direction: 'none', nextDirection: 'none',
                score: 0, isAlive: true, speed: GAME_SPEED, powerUpTimer: 0, lastMoveTime: 0,
                ...config
            };
        }

        function resetPlayer(player, collisionType) {
            playErrorSound();
            let startPos;
            switch(player.id) {
                case 1: startPos = { x: 3, y: 3 }; break;
                case 2: startPos = { x: tileCountX - 4, y: 3 }; break;
                case 3: startPos = { x: 3, y: tileCountY - 4 }; break;
                case 4: startPos = { x: tileCountX - 4, y: tileCountY - 4 }; break;
            }
            player.snake = [startPos];
            player.direction = 'none';
            player.nextDirection = 'none';
            player.speed = GAME_SPEED;
            player.powerUpTimer = 0;
            if (collisionType === 'wall' || collisionType === 'self') player.score = 0;
            else if (collisionType === 'player') player.score = Math.max(0, player.score - 5);
            updateScoreboard();
        }

        // --- Game Start/End ---
        function startGame() {
            const victoryButtons = [playAgainBtnWin, exitBtnWin];
            victoryButtons.forEach(btn => {
                btn.style.backgroundColor = ''; btn.style.color = '';
                btn.style.boxShadow = ''; btn.onmouseover = null; btn.onmouseout = null;
            });
            menuScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameScreen.classList.add('flex');
            setupCanvas();
            winningScore = parseInt(scoreSlider.value);
            players = [];
            for (let i = 1; i <= playerCount; i++) players.push(createPlayer(i));
            powerup.active = false;
            updateScoreboard();
            generateFood();
            lastFrameTime = Date.now();
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, RENDER_INTERVAL);
        }

        function endGame(winner) {
            playWinSound();
            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
            winnerText.textContent = `Player ${winner.id} Wins!`;
            winnerText.style.color = winner.color;
            winnerText.style.textShadow = `0 0 5px #fff, 0 0 10px #fff, 0 0 20px ${winner.color}, 0 0 30px ${winner.color}, 0 0 40px ${winner.color}, 0 0 55px ${winner.color}, 0 0 75px ${winner.color}`;
            const randomIndex = Math.floor(Math.random() * insults.length);
            insultText.textContent = `"${insults[randomIndex]}"`;
            const victoryButtons = [playAgainBtnWin, exitBtnWin];
            victoryButtons.forEach(btn => {
                btn.style.backgroundColor = winner.color;
                btn.style.color = '#121212';
                btn.style.boxShadow = `0 0 15px ${winner.color}`;
                btn.onmouseover = () => { btn.style.backgroundColor = '#FFFFFF'; btn.style.color = winner.color; btn.style.boxShadow = `0 0 25px ${winner.color}`; };
                btn.onmouseout = () => { btn.style.backgroundColor = winner.color; btn.style.color = '#121212'; btn.style.boxShadow = `0 0 15px ${winner.color}`; };
            });
            gameScreen.classList.add('hidden');
            gameScreen.classList.remove('flex');
            gameOverScreen.classList.remove('hidden');
        }
        
        function togglePause() {
            if (!gameLoopInterval && !isPaused) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
                pauseScreen.classList.remove('hidden');
            } else {
                lastFrameTime = Date.now();
                pauseScreen.classList.add('hidden');
                gameLoopInterval = setInterval(gameLoop, RENDER_INTERVAL);
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;
            updateGameState(deltaTime);
            drawGame();
        }

        function updateGameState(deltaTime) {
            updatePowerupState(deltaTime);
            players.forEach(player => movePlayer(player, deltaTime));
        }
        
        function movePlayer(player, deltaTime) {
            if (player.powerUpTimer > 0) {
                player.powerUpTimer -= deltaTime;
                if (player.powerUpTimer <= 0) {
                    player.powerUpTimer = 0;
                    player.speed = GAME_SPEED;
                }
            }
            if (Date.now() - player.lastMoveTime < player.speed) return;
            player.lastMoveTime = Date.now();
            if (player.nextDirection !== 'none') {
                const isOpposite = (d1, d2) => (d1 === 'up' && d2 === 'down') || (d1 === 'down' && d2 === 'up') || (d1 === 'left' && d2 === 'right') || (d1 === 'right' && d2 === 'left');
                if (!isOpposite(player.direction, player.nextDirection)) player.direction = player.nextDirection;
                player.nextDirection = 'none';
            }
            if (player.direction === 'none') return;
            const head = { ...player.snake[0] };
            switch (player.direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            const collisionType = checkCollision(head, player);
            if (collisionType) { resetPlayer(player, collisionType); return; }
            player.snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                playFoodSound();
                player.score++;
                updateScoreboard(player.id);
                if (player.score >= winningScore) endGame(player); else generateFood();
            } else if (powerup.active && head.x === powerup.x && head.y === powerup.y) {
                playPowerupSound();
                player.speed = GAME_SPEED * 0.5;
                player.powerUpTimer = POWERUP_DURATION;
                powerup.active = false;
            } else { player.snake.pop(); }
        }

        // --- Collision, Food & Powerup Logic ---
        function checkCollision(head, currentPlayer) {
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) return 'wall';
            for (let i = 1; i < currentPlayer.snake.length; i++) if (head.x === currentPlayer.snake[i].x && head.y === currentPlayer.snake[i].y) return 'self';
            for (const otherPlayer of players) {
                if (otherPlayer.id === currentPlayer.id) continue;
                for (const segment of otherPlayer.snake) if (head.x === segment.x && head.y === segment.y) return 'player';
            }
            return false;
        }

        function isPositionOccupied(pos) {
            for (const p of players) for (const seg of p.snake) if (seg.x === pos.x && seg.y === pos.y) return true;
            if (food.x === pos.x && food.y === pos.y) return true;
            if (powerup.active && powerup.x === pos.x && powerup.y === pos.y) return true;
            return false;
        }

        function generateItem(itemType) {
            let position;
            do {
                position = { x: Math.floor(Math.random() * tileCountX), y: Math.floor(Math.random() * tileCountY) };
            } while (isPositionOccupied(position));
            return position;
        }
        
        function generateFood() { food = generateItem(); }
        
        function updatePowerupState(deltaTime) {
            if (powerup.active) {
                powerup.lifespan -= deltaTime;
                if (powerup.lifespan <= 0) powerup.active = false;
            } else if (Math.random() < POWERUP_SPAWN_CHANCE) {
                const pos = generateItem();
                powerup = { active: true, x: pos.x, y: pos.y, lifespan: POWERUP_LIFESPAN, pulseState: 0 };
            }
        }

        // --- Drawing & UI ---
        function drawGame() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF'; ctx.shadowColor = '#FFFFFF'; ctx.shadowBlur = 10;
            ctx.fillRect(food.x * TILE_SIZE, food.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            if (powerup.active) {
                powerup.pulseState += 0.1;
                const pulseSize = Math.sin(powerup.pulseState) * 2;
                const size = TILE_SIZE + pulseSize;
                const offset = (TILE_SIZE - size) / 2;
                ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 15;
                ctx.fillRect((powerup.x * TILE_SIZE) + offset, (powerup.y * TILE_SIZE) + offset, size, size);
            }
            players.forEach(player => {
                const lighterColor = (player.powerUpTimer > 0) ? lightenHexColor(player.color, 40) : null;
                ctx.shadowColor = player.color; ctx.shadowBlur = 5;
                player.snake.forEach((segment, index) => {
                    ctx.globalAlpha = (index === 0) ? 1.0 : 0.8;
                    ctx.fillStyle = (lighterColor && index % 2 !== 0) ? lighterColor : player.color;
                    ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                });
            });
            ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
        }

        function updateScoreboard(highlightPlayerId = null) {
            scoreboard.innerHTML = '';
            players.forEach(player => {
                const scoreElement = document.createElement('div');
                scoreElement.id = `player-${player.id}-score`;
                scoreElement.className = 'player-score p-2 rounded-md';
                scoreElement.style.color = player.color;
                scoreElement.textContent = `P${player.id}: ${player.score}`;
                scoreboard.appendChild(scoreElement);
                if (player.id === highlightPlayerId) {
                    scoreElement.classList.add('highlight');
                    setTimeout(() => scoreElement.classList.remove('highlight'), 300);
                }
            });
        }
        
        function lightenHexColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            const p = percent / 100;
            r = Math.min(255, Math.floor(r * (1 + p)));
            g = Math.min(255, Math.floor(g * (1 + p)));
            b = Math.min(255, Math.floor(b * (1 + p)));
            return `#${(r).toString(16).padStart(2, '0')}${(g).toString(16).padStart(2, '0')}${(b).toString(16).padStart(2, '0')}`;
        }

        // --- Input Handling ---
        function handleKeyPress(e) {
            if (e.code === 'Escape') { e.preventDefault(); togglePause(); return; }
            if (isPaused) return;
            const isGameKey = players.some(p => p.controls[e.code]);
            if (isGameKey) e.preventDefault();
            if (!gameLoopInterval) return;
            players.forEach(player => { if (player.controls[e.code]) player.nextDirection = player.controls[e.code]; });
        }
    </script>

</body>
</html>


